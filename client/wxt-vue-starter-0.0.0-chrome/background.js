var background=function(){"use strict";var Ee=Object.defineProperty;var fe=(b,I,C)=>I in b?Ee(b,I,{enumerable:!0,configurable:!0,writable:!0,value:C}):b[I]=C;var M=(b,I,C)=>fe(b,typeof I!="symbol"?I+"":I,C);var z,Z,ee,te;function b(n){return n==null||typeof n=="function"?{main:n}:n}const I=((Z=(z=globalThis.browser)==null?void 0:z.runtime)==null?void 0:Z.id)==null?globalThis.chrome:globalThis.browser;var C=Object.prototype.hasOwnProperty;function $(n,e){var t,o;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((o=n.length)===e.length)for(;o--&&$(n[o],e[o]););return o===-1}if(!t||typeof n=="object"){o=0;for(t in n)if(C.call(n,t)&&++o&&!C.call(e,t)||!(t in e)||!$(n[t],e[t]))return!1;return Object.keys(e).length===o}}return n!==n&&e!==e}const re=new Error("request for lock canceled");var ne=function(n,e,t,o){function h(c){return c instanceof t?c:new t(function(d){d(c)})}return new(t||(t=Promise))(function(c,d){function y(w){try{v(o.next(w))}catch(T){d(T)}}function S(w){try{v(o.throw(w))}catch(T){d(T)}}function v(w){w.done?c(w.value):h(w.value).then(y,S)}v((o=o.apply(n,e||[])).next())})};class se{constructor(e,t=re){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((o,h)=>{const c={resolve:o,reject:h,weight:e,priority:t},d=Q(this._queue,y=>t<=y.priority);d===-1&&e<=this._value?this._dispatchItem(c):this._queue.splice(d+1,0,c)})}runExclusive(e){return ne(this,arguments,void 0,function*(t,o=1,h=0){const[c,d]=yield this.acquire(o,h);try{return yield t(c)}finally{d()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(o=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),ie(this._weightedWaiters[e-1],{resolve:o,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(o=>o.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const o=this._weightedWaiters[t-1];if(!o)continue;const h=o.findIndex(c=>c.priority<=e);(h===-1?o:o.splice(0,h)).forEach(c=>c.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function ie(n,e){const t=Q(n,o=>e.priority<=o.priority);n.splice(t+1,0,e)}function Q(n,e){for(let t=n.length-1;t>=0;t--)if(e(n[t]))return t;return-1}var oe=function(n,e,t,o){function h(c){return c instanceof t?c:new t(function(d){d(c)})}return new(t||(t=Promise))(function(c,d){function y(w){try{v(o.next(w))}catch(T){d(T)}}function S(w){try{v(o.throw(w))}catch(T){d(T)}}function v(w){w.done?c(w.value):h(w.value).then(y,S)}v((o=o.apply(n,e||[])).next())})};class ce{constructor(e){this._semaphore=new se(1,e)}acquire(){return oe(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const V=((te=(ee=globalThis.browser)==null?void 0:ee.runtime)==null?void 0:te.id)==null?globalThis.chrome:globalThis.browser,B=le();function le(){const n={local:x("local"),session:x("session"),sync:x("sync"),managed:x("managed")},e=s=>{const r=n[s];if(r==null){const a=Object.keys(n).join(", ");throw Error(`Invalid area "${s}". Options: ${a}`)}return r},t=s=>{const r=s.indexOf(":"),a=s.substring(0,r),i=s.substring(r+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${s}"`);return{driverArea:a,driverKey:i,driver:e(a)}},o=s=>s+"$",h=(s,r)=>{const a={...s};return Object.entries(r).forEach(([i,l])=>{l==null?delete a[i]:a[i]=l}),a},c=(s,r)=>s??r??null,d=s=>typeof s=="object"&&!Array.isArray(s)?s:{},y=async(s,r,a)=>{const i=await s.getItem(r);return c(i,(a==null?void 0:a.fallback)??(a==null?void 0:a.defaultValue))},S=async(s,r)=>{const a=o(r),i=await s.getItem(a);return d(i)},v=async(s,r,a)=>{await s.setItem(r,a??null)},w=async(s,r,a)=>{const i=o(r),l=d(await s.getItem(i));await s.setItem(i,h(l,a))},T=async(s,r,a)=>{if(await s.removeItem(r),a!=null&&a.removeMeta){const i=o(r);await s.removeItem(i)}},R=async(s,r,a)=>{const i=o(r);if(a==null)await s.removeItem(i);else{const l=d(await s.getItem(i));[a].flat().forEach(u=>delete l[u]),await s.setItem(i,l)}},A=(s,r,a)=>s.watch(r,a);return{getItem:async(s,r)=>{const{driver:a,driverKey:i}=t(s);return await y(a,i,r)},getItems:async s=>{const r=new Map,a=new Map,i=[];s.forEach(u=>{let m,E;typeof u=="string"?m=u:"getValue"in u?(m=u.key,E={fallback:u.fallback}):(m=u.key,E=u.options),i.push(m);const{driverArea:P,driverKey:p}=t(m),_=r.get(P)??[];r.set(P,_.concat(p)),a.set(m,E)});const l=new Map;return await Promise.all(Array.from(r.entries()).map(async([u,m])=>{(await n[u].getItems(m)).forEach(P=>{const p=`${u}:${P.key}`,_=a.get(p),f=c(P.value,(_==null?void 0:_.fallback)??(_==null?void 0:_.defaultValue));l.set(p,f)})})),i.map(u=>({key:u,value:l.get(u)}))},getMeta:async s=>{const{driver:r,driverKey:a}=t(s);return await S(r,a)},getMetas:async s=>{const r=s.map(l=>{const u=typeof l=="string"?l:l.key,{driverArea:m,driverKey:E}=t(u);return{key:u,driverArea:m,driverKey:E,driverMetaKey:o(E)}}),a=r.reduce((l,u)=>{var m;return l[m=u.driverArea]??(l[m]=[]),l[u.driverArea].push(u),l},{}),i={};return await Promise.all(Object.entries(a).map(async([l,u])=>{const m=await V.storage[l].get(u.map(E=>E.driverMetaKey));u.forEach(E=>{i[E.key]=m[E.driverMetaKey]??{}})})),r.map(l=>({key:l.key,meta:i[l.key]}))},setItem:async(s,r)=>{const{driver:a,driverKey:i}=t(s);await v(a,i,r)},setItems:async s=>{const r={};s.forEach(a=>{const{driverArea:i,driverKey:l}=t("key"in a?a.key:a.item.key);r[i]??(r[i]=[]),r[i].push({key:l,value:a.value})}),await Promise.all(Object.entries(r).map(async([a,i])=>{await e(a).setItems(i)}))},setMeta:async(s,r)=>{const{driver:a,driverKey:i}=t(s);await w(a,i,r)},setMetas:async s=>{const r={};s.forEach(a=>{const{driverArea:i,driverKey:l}=t("key"in a?a.key:a.item.key);r[i]??(r[i]=[]),r[i].push({key:l,properties:a.meta})}),await Promise.all(Object.entries(r).map(async([a,i])=>{const l=e(a),u=i.map(({key:p})=>o(p));console.log(a,u);const m=await l.getItems(u),E=Object.fromEntries(m.map(({key:p,value:_})=>[p,d(_)])),P=i.map(({key:p,properties:_})=>{const f=o(p);return{key:f,value:h(E[f]??{},_)}});await l.setItems(P)}))},removeItem:async(s,r)=>{const{driver:a,driverKey:i}=t(s);await T(a,i,r)},removeItems:async s=>{const r={};s.forEach(a=>{let i,l;typeof a=="string"?i=a:"getValue"in a?i=a.key:"item"in a?(i=a.item.key,l=a.options):(i=a.key,l=a.options);const{driverArea:u,driverKey:m}=t(i);r[u]??(r[u]=[]),r[u].push(m),l!=null&&l.removeMeta&&r[u].push(o(m))}),await Promise.all(Object.entries(r).map(async([a,i])=>{await e(a).removeItems(i)}))},clear:async s=>{await e(s).clear()},removeMeta:async(s,r)=>{const{driver:a,driverKey:i}=t(s);await R(a,i,r)},snapshot:async(s,r)=>{var l;const i=await e(s).snapshot();return(l=r==null?void 0:r.excludeKeys)==null||l.forEach(u=>{delete i[u],delete i[o(u)]}),i},restoreSnapshot:async(s,r)=>{await e(s).restoreSnapshot(r)},watch:(s,r)=>{const{driver:a,driverKey:i}=t(s);return A(a,i,r)},unwatch(){Object.values(n).forEach(s=>{s.unwatch()})},defineItem:(s,r)=>{const{driver:a,driverKey:i}=t(s),{version:l=1,migrations:u={}}=r??{};if(l<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const m=async()=>{var ae;const f=o(i),[{value:K},{value:U}]=await a.getItems([i,f]);if(K==null)return;const G=(U==null?void 0:U.v)??1;if(G>l)throw Error(`Version downgrade detected (v${G} -> v${l}) for "${s}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${s}: v${G} -> v${l}`);const me=Array.from({length:l-G},(F,H)=>G+H+1);let D=K;for(const F of me)try{D=await((ae=u==null?void 0:u[F])==null?void 0:ae.call(u,D))??D}catch(H){throw Error(`v${F} migration failed for "${s}"`,{cause:H})}await a.setItems([{key:i,value:D},{key:f,value:{...U,v:l}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${s} v${l}`,{migratedValue:D})},E=(r==null?void 0:r.migrations)==null?Promise.resolve():m().catch(f=>{console.error(`[@wxt-dev/storage] Migration failed for ${s}`,f)}),P=new ce,p=()=>(r==null?void 0:r.fallback)??(r==null?void 0:r.defaultValue)??null,_=()=>P.runExclusive(async()=>{const f=await a.getItem(i);if(f!=null||(r==null?void 0:r.init)==null)return f;const K=await r.init();return await a.setItem(i,K),K});return E.then(_),{key:s,get defaultValue(){return p()},get fallback(){return p()},getValue:async()=>(await E,r!=null&&r.init?await _():await y(a,i,r)),getMeta:async()=>(await E,await S(a,i)),setValue:async f=>(await E,await v(a,i,f)),setMeta:async f=>(await E,await w(a,i,f)),removeValue:async f=>(await E,await T(a,i,f)),removeMeta:async f=>(await E,await R(a,i,f)),watch:f=>A(a,i,(K,U)=>f(K??p(),U??p())),migrate:m}}}}function x(n){const e=()=>{if(V.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(V.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const o=V.storage[n];if(o==null)throw Error(`"browser.storage.${n}" is undefined`);return o},t=new Set;return{getItem:async o=>(await e().get(o))[o],getItems:async o=>{const h=await e().get(o);return o.map(c=>({key:c,value:h[c]??null}))},setItem:async(o,h)=>{h==null?await e().remove(o):await e().set({[o]:h})},setItems:async o=>{const h=o.reduce((c,{key:d,value:y})=>(c[d]=y,c),{});await e().set(h)},removeItem:async o=>{await e().remove(o)},removeItems:async o=>{await e().remove(o)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async o=>{await e().set(o)},watch(o,h){const c=d=>{const y=d[o];y!=null&&($(y.newValue,y.oldValue)||h(y.newValue??null,y.oldValue??null))};return e().onChanged.addListener(c),t.add(c),()=>{e().onChanged.removeListener(c),t.delete(c)}},unwatch(){t.forEach(o=>{e().onChanged.removeListener(o)}),t.clear()}}}class ue{constructor(){M(this,"noWallet",{code:0,message:"No wallet"});M(this,"userReject",{code:1,message:"User rejected"})}}const L=new ue;var Y=(n=>(n.LIVENET="livenet",n.TESTNET="testnet",n))(Y||{});const X={locked:!0,hasWallet:!1,address:null,isConnected:!1,network:Y.LIVENET,walletId:0,accountIndex:0,balance:{confirmed:0,unconfirmed:0,total:0},pubkey:null},k=class k{constructor({storageType:e="local"}){M(this,"state");M(this,"storageType");this.storageType=e,this.state=JSON.parse(JSON.stringify(X))}static getInstance(e={storageType:"local"}){return k.instance||(k.instance=new k(e)),k.instance}getStorageKey(e){return`${this.storageType}:wallet_${e}`}async initializeState(){for(const e of Object.keys(this.state)){const t=await B.getItem(this.getStorageKey(e));t!==null&&(this.state[e]=t)}}async persistState(e,t){await B.setItem(this.getStorageKey(e),t)}get address(){return this.state.address}get locked(){return this.state.locked}get isConnected(){return this.state.isConnected}get network(){return this.state.network}get walletId(){return this.state.walletId}get accountIndex(){return this.state.accountIndex}get hasWallet(){return this.state.hasWallet}get balance(){return this.state.balance}get pubkey(){return this.state.pubkey}set address(e){this.state.address=e,this.persistState("address",e)}set locked(e){this.state.locked=e,this.persistState("locked",e)}set isConnected(e){this.state.isConnected=e,this.persistState("isConnected",e)}set hasWallet(e){this.state.hasWallet=e,this.persistState("hasWallet",e)}set network(e){this.state.network=e,this.persistState("network",e)}set walletId(e){this.state.walletId=e,this.persistState("walletId",e)}set accountIndex(e){this.state.accountIndex=e,this.persistState("accountIndex",e)}set balance(e){this.state.balance=e,this.persistState("balance",e)}set pubkey(e){this.state.pubkey=e,this.persistState("pubkey",e)}async clear(){const e=Object.keys(this.state).map(t=>this.getStorageKey(t));await B.removeItems(e),this.state=JSON.parse(JSON.stringify(X))}};M(k,"instance",null);let j=k;const N=j.getInstance();class de{async getHasWallet(){return console.log("walletStorage.hasWallet:",N),console.log("walletStorage.hasWallet:",N.hasWallet),N.hasWallet}async getAccounts(){const e=N.address;return e?[e]:[]}async getNetwork(){return N.network}async getPublicKey(){const e=N.pubkey;if(!e)throw new Error("Public key not available");return e}async getBalance(){return N.balance}async pushTx(e){throw new Error("Not implemented")}async pushPsbt(e){throw new Error("Not implemented")}}const O=new de,he=(n,e={})=>{const{width:t=375,height:o=700}=e;return new Promise(h=>{I.windows.create({url:n,type:"popup",width:t,height:o},c=>{h(c)})})};var g;(n=>{(e=>{e.INJECT_CONTENT="INJECT_CONTENT",e.BG_POPUP="BG_POPUP"})(n.Channel||(n.Channel={})),(e=>{e.INJECT_CONTENT="INJECT_CONTENT",e.CONTENT_BG="CONTENT_BG",e.BG_POPUP="BG_POPUP"})(n.Port||(n.Port={})),(e=>{e.REQUEST="REQUEST",e.APPROVE="APPROVE",e.EVENT="EVENT"})(n.MessageType||(n.MessageType={})),(e=>{e.INJECTED="INJECTED",e.CONTENT="CONTENT",e.BACKGROUND="BACKGROUND",e.POPUP="POPUP"})(n.MessageFrom||(n.MessageFrom={})),(e=>{e.INJECTED="INJECTED",e.CONTENT="CONTENT",e.BACKGROUND="BACKGROUND",e.POPUP="POPUP"})(n.MessageTo||(n.MessageTo={})),(e=>{e.GET_APPROVE_DATA="GET_APPROVE_DATA",e.GET_APPROVE_DATA_RESPONSE="GET_APPROVE_DATA_RESPONSE",e.APPROVE_RESPONSE="APPROVE_RESPONSE",e.REJECT_RESPONSE="REJECT_RESPONSE",e.REQUEST_ACCOUNTS="REQUEST_ACCOUNTS",e.GET_ACCOUNTS="GET_ACCOUNTS",e.GET_NETWORK="GET_NETWORK",e.SWITCH_NETWORK="SWITCH_NETWORK",e.GET_PUBLIC_KEY="GET_PUBLIC_KEY",e.GET_BALANCE="GET_BALANCE",e.SEND_BITCOIN="SEND_BITCOIN",e.SIGN_MESSAGE="SIGN_MESSAGE",e.SIGN_PSBT="SIGN_PSBT",e.SIGN_PSBTS="SIGN_PSBTS",e.PUSH_TX="PUSH_TX",e.PUSH_PSBT="PUSH_PSBT",e.GET_INSCRIPTIONS="GET_INSCRIPTIONS",e.SEND_INSCRIPTION="SEND_INSCRIPTION"})(n.MessageAction||(n.MessageAction={}))})(g||(g={}));const we=b(async()=>{console.log("Hello background!",{id:I.runtime.id});const n=new Map;let e=null;const t={},o=async h=>{const c=h,{action:d,data:y,metadata:S={}}=c,{windowId:v,from:w,messageId:T}=S;if(console.log("Background 收到 popup 消息:",c),w===g.MessageFrom.POPUP)if(d===g.MessageAction.GET_APPROVE_DATA){const R=n.get(v.toString());R&&t.popup.postMessage({metadata:{from:g.MessageFrom.BACKGROUND,to:g.MessageTo.POPUP,windowId:v,messageId:T},action:g.MessageAction.GET_APPROVE_DATA_RESPONSE,data:R.eventData})}else d===g.MessageAction.APPROVE_RESPONSE?(console.log("Background 收到 Approve Response:",c),c.metadata.from=g.MessageFrom.BACKGROUND,c.metadata.to=g.MessageTo.INJECTED,await t.content.postMessage(c)):d===g.MessageAction.REJECT_RESPONSE&&(console.log("Background 收到 Reject Response:",c),c.metadata.from=g.MessageFrom.BACKGROUND,c.metadata.to=g.MessageTo.INJECTED,t.content.postMessage({...c,data:null,error:L.userReject}),n.delete(v.toString()),t.popup.disconnect(),I.windows.remove(v))};I.runtime.onConnect.addListener(async h=>{if(console.log(`来自 Tab 的连接: ${h.name}`),h.name===g.Port.BG_POPUP){t.popup=h,console.log(t.popup),h.postMessage({type:"CONNECTION_READY"});const c=await chrome.windows.getCurrent();if(c!=null&&c.id){const d=n.get(c.id.toString());d&&t.popup.onDisconnect.addListener(()=>{t.content.postMessage({...d.eventData,data:null,error:L.userReject})})}console.log("Popup 连接 Background 成功"),t.popup.onMessage.addListener(o)}else h.name===g.Port.CONTENT_BG&&(t.content=h,t.content.onMessage.addListener(async c=>{console.log("BACKGROUND 收到 CONTENT 消息:",c),await N.initializeState();const d=c,{action:y,type:S}=d;d.metadata.from=g.MessageFrom.BACKGROUND,d.metadata.to=g.MessageTo.INJECTED;const v=async()=>{const T=await O.getHasWallet();return console.log(await B.getItem("local:wallet_hasWallet")),T||t.content.postMessage({...d,data:null,error:L.noWallet}),T};let w;if(S===g.MessageType.REQUEST){if(await v()){switch(y){case g.MessageAction.GET_ACCOUNTS:w=await O.getAccounts();break;case g.MessageAction.GET_PUBLIC_KEY:w=await O.getPublicKey();break;case g.MessageAction.GET_NETWORK:w=await O.getNetwork();break;case g.MessageAction.GET_PUBLIC_KEY:w=await O.getPublicKey();break;case g.MessageAction.GET_BALANCE:w=await O.getBalance();break;case g.MessageAction.PUSH_TX:w=await O.pushTx(d.data);break;case g.MessageAction.PUSH_PSBT:w=await O.pushPsbt(d.data);break}t.content.postMessage({...d,data:w})}}else if(S===g.MessageType.APPROVE&&await v()){const{origin:R}=d.metadata;for(const[J,s]of n.entries())if(s.eventData.metadata.origin===R)try{await I.windows.remove(parseInt(J)),n.delete(J)}catch{}const A=await he(I.runtime.getURL("/popup.html#/wallet/approve"));e=A==null?void 0:A.id,console.log("创建窗口:",A),n.set(e.toString(),{windowId:e,eventData:c}),console.log("approveMap:",n)}}))})});function ye(){}function W(n,...e){}const ge={debug:(...n)=>W(console.debug,...n),log:(...n)=>W(console.log,...n),warn:(...n)=>W(console.warn,...n),error:(...n)=>W(console.error,...n)};let q;try{q=we.main(),q instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(n){throw ge.error("The background crashed on startup!"),n}return q}();
background;
